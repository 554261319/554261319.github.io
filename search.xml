<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot-配置文件]]></title>
    <url>%2F2018%2F08%2F28%2FSpringBoot-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Spring Boot 允许通过外部配置让你在不同的环境使用同一应用程序的代码，简单说就是可以通过配置文件来注入属性或者修改默认的配置。 配置文件YAML配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的： application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值，SpringBoot在底层都自动配置好。 YAML（YAML Ain’t Markup Language） 标记语言： 以前的配置文件，大多都使用的是 **xxxx.xml**文件。 YAML：**以数据为中心**，比json xml等更适合做配置文件。 YAML：配置例子 12server: port: 8081 XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML语法基本语法k:(空格)v：表示一对键值对（空格必须有）。 以空格的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的。 123server: port: 8081 path: /hello 属性和值也是大小写敏感。 值的写法字面量：普通的值（数字，字符串，布尔）k: v：字面直接来写。 字符串默认不用加上单引号或者双引号 “ “：双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思 name: &quot;zhangsan \n lisi&quot; 输出：zhangsan 换行 lisi ‘ ‘：单引号，会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: ‘zhangsan \n lisi’ 输出：zhangsan \n lisi 对象 Map（属性和值）（键值对）k: v：在下一行来写对象的属性和值的关系，要注意缩进 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List Set）用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; properties配置文件在idea中默认utf-8可能会乱码@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量 配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量 配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式，推荐使用全注解的方式 1 配置类@Configuration——&gt;Spring配置文件 2 使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; 配置文件占位符随机数12$&#123;random.value&#125; $&#123;random.int&#125; $&#123;random.long&#125;$&#123;random.int(10)&#125; $&#123;random.int[1024,65536]&#125; 占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 Profile多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置 yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile1 在配置文件中指定 spring.profiles.active=dev 2 命令行： java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev； 可以直接在测试的时候，配置传入命令行参数 3 虚拟机参数； -Dspring.profiles.active=dev 配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置 SpringBoot会从这四个位置全部加载主配置文件，互补配置 我们还可以通过spring.config.location来改变默认的配置文件位置 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源 参考官方文档 自动配置原理配置文件到底能写什么？怎么写？自动配置原理 配置文件能配置的属性参照 自动配置原理：1） SpringBoot启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration 2） @EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容 List configurations = getCandidateConfigurations(annotationMetadata,attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置 3） 每一个自动配置类进行自动配置功能 4） 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。 5） 所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘，配置文件能配置什么就可以参照某个功能对应的这个属性类。 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： **1） SpringBoot启动会加载大量的自动配置类** **2） 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类** **3） 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）** **4） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值** xxxxAutoConfigurartion：自动配置类 给容器中添加组件 xxxxProperties:封装配置文件中相关属性 细节Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效 我们怎么知道哪些自动配置类生效 我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot-入门篇]]></title>
    <url>%2F2018%2F08%2F26%2FSpringBoot-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[SpringBoot就是简化Spring应用开发的一个框架，整个Spring技术栈的一个大整合，J2EE开发的一站式解决方案。 Spring Boot HelloWorld1. 创建一个maven工程2. 导入Spring Boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3. 编写一个主程序,启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4. 编写相关的Controller Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5. 运行主程序测试6. 简化部署123456789 &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行 Hello World探究POM文件1. 父项目12345678910111213&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本仲裁中心以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的依赖自然需要声明版本号） 2. 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件。 Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器。 主程序类，主入口类12345678//@SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication：SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; @SpringBootConfiguration: Spring Boot的配置类，标注在某个类上，表示这是一个Spring Boot的配置类。 @Configuration（Spring中已经定义的注解）: 配置类上来标注这个注解，配置类也就是我们之前写的配置文件，配置类也是容器中的一个组件@Component。 @EnableAutoConfiguration： 开启自动配置功能以前我们需要配置的东西，Spring Boot帮我们自动配置，@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效。 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; @AutoConfigurationPackage：自动配置。 @Import(AutoConfigurationPackages.Registrar.class)： Spring的底层注解@Import，给容器中导入一个组件，导入的组件由AutoConfigurationPackages.Registrar.class将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器。 @Import(EnableAutoConfigurationImportSelector.class)： 给容器中导入什么组件？EnableAutoConfigurationImportSelector：主要作用是导入哪些组件的选择器，将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容，器中会给容器中导入非常多的自动配置类（xxxAutoConfiguration），自动配置类的作用就是给容器中导入这个场景需要的所有组件，并配置好这些组件。有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。 自动配置类是如何加载到的？ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)： Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取，EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作，以前我们需要自己配置的东西，自动配置类都帮我们。 J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar 使用Spring Initializer快速创建Spring Boot项目IDEA：使用 Spring Initializer快速创建项目 IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目 选择我们需要的模块，向导会联网创建Spring Boot项目 默认生成的Spring Boot项目 主程序已经生成好了，我们只需要我们自己的逻辑。 resources文件夹中目录结构 static：保存所有的静态资源； js css images templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面），可以使用模板引擎（freemarker thymeleaf） application.properties：Spring Boot应用的配置文件，可以修改一些默认设置 STS使用 Spring Starter Project快速创建项目]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax知识体系梳理]]></title>
    <url>%2F2018%2F05%2F12%2FAjax%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Ajax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. 它最早在IE5中被使用, 然后由Mozilla, Apple, Google推广开来. 典型的代表应用有 Outlook Web Access, 以及 GMail. 现代网页中几乎无ajax不欢. 前后端分离也正是建立在ajax异步通信的基础之上. 浏览器为ajax做了什么现代浏览器中, 虽然几乎全部支持ajax, 但它们的技术方案却分为两种: ① 标准浏览器通过 XMLHttpRequest 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象. 1var xhr = new XMLHttpRequest(); ② IE浏览器通过 XMLHttpRequest 或者 ActiveXObject 对象同样实现了ajax的功能. MSXML鉴于IE系列各种 “神级” 表现, 我们先来看看IE浏览器风骚的走位. IE下的使用环境略显复杂, IE7及更高版本浏览器可以直接使用BOM的 XMLHttpRequest 对象. MSDN传送门: Native XMLHTTPRequest object. IE6及更低版本浏览器只能使用 ActiveXObject 对象来创建 XMLHttpRequest 对象实例. 创建时需要指明一个类似”Microsoft.XMLHTTP”这样的ProgID. 而实际呢, windows系统环境下, 以下ProgID都应该可以创建XMLHTTP对象: 12345678910111213Microsoft.XMLHTTPMicrosoft.XMLHTTP.1.0Msxml2.ServerXMLHTTPMsxml2.ServerXMLHTTP.3.0Msxml2.ServerXMLHTTP.4.0Msxml2.ServerXMLHTTP.5.0Msxml2.ServerXMLHTTP.6.0Msxml2.XMLHTTPMsxml2.XMLHTTP.3.0Msxml2.XMLHTTP.4.0Msxml2.XMLHTTP.5.0Msxml2.XMLHTTP.6.0123456789101112 简言之, Microsoft.XMLHTTP 已经非常老了, 主要用于提供对历史遗留版本的支持, 不建议使用.对于 MSXML4, 它已被 MSXML6 替代; 而 MSXML5 又是专门针对office办公场景, 在没有安装 Microsoft Office 2003 及更高版本办公软件的情况下, MSXML5 未必可用. 相比之下, MSXML6 具有比 MSXML3 更稳定, 更高性能, 更安全的优势, 同时它也提供了一些 MSXML3 中没有的功能, 比如说 XSD schema. 唯一遗憾的是, MSXML6 只在 vista 系统及以上才是默认支持的; 而 MSXML3 在 Win2k SP4及以上系统就是可用的. 因此一般情况下, MSXML3 可以作为 MSXML6 的优雅降级方案, 我们通过指定 PorgID 为 Msxml2.XMLHTTP 即可自动映射到 Msxml2.XMLHTTP.3.0. 如下所示: 123var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3,等同于如下语句var xhr = new ActiveXObject(&quot;MSXML2.XMLHTTP.3.0&quot;);12 MSDN有篇文章专门讲解了各个版本的MSXML. 传送门: Using the right version of MSXML in Internet Explorer. 亲测了 IE5, IE5.5, IE6, IE7, IE8, IE9, IE10, IE edge等浏览器, IE5及之后的浏览器均可以通过如下语句获取xhr对象: 123var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用12 以上, 思路已经很清晰了, 下面给出个全兼容的方法. 全平台兼容的XMLHttpRequest对象123456789101112131415161718function getXHR()&#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e) &#123; alert(&quot;您的浏览器暂不支持Ajax!&quot;); &#125; &#125; &#125; return xhr;&#125;1234567891011121314151617 ajax有没有破坏js单线程机制对于这个问题, 我们先看下浏览器线程机制. 一般情况下, 浏览器有如下四种线程: GUI渲染线程 javascript引擎线程 浏览器事件触发线程 HTTP请求线程 那么这么多线程, 它们究竟是怎么同js引擎线程交互的呢? 通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到任务队列 的末尾 , 等到js引擎空闲时, 任务队列 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调. 浏览器中, js引擎线程会循环从 任务队列 中读取事件并且执行, 这种运行机制称作 Event Loop (事件循环). 对于一个ajax请求, js引擎首先生成 XMLHttpRequest 实例对象, open过后再调用send方法. 至此, 所有的语句都是同步执行. 但从send方法内部开始, 浏览器为将要发生的网络请求创建了新的http请求线程, 这个线程独立于js引擎线程, 于是网络请求异步被发送出去了. 另一方面, js引擎并不会等待 ajax 发起的http请求收到结果, 而是直接顺序往下执行. 当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 onreadystatechange (当然也可能触发onload, 或者 onerror等等) . 该回调事件并没有被立即执行, 而是被添加到 任务队列 的末尾. 直到js引擎空闲了, 任务队列 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 onreadystatechange 事件. 在 onreadystatechange 事件内部, 有可能对dom进行操作. 此时浏览器便会挂起js引擎线程, 转而执行GUI渲染线程, 进行UI重绘(repaint)或者回流(reflow). 当js引擎重新执行时, GUI渲染线程又会被挂起, GUI更新将被保存起来, 等到js引擎空闲时立即被执行. 以上整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 GUI渲染线程 和 js引擎线程 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制. ajax与setTimeout排队问题通常, ajax 和 setTimeout 的事件回调都被同等的对待, 按照顺序自动的被添加到 任务队列 的末尾, 等待js引擎空闲时执行. 但请注意, 并非xhr的所有回调执行都滞后于setTImeout的回调. 请看如下代码: 1234567891011121314151617181920212223242526272829setTimeout(function()&#123; console.log(&apos;setTimeout&apos;);&#125;,0);var resolve;new Promise(function(r)&#123; resolve = r;&#125;).then(function()&#123; console.log(&apos;promise nextTick&apos;);&#125;);resolve();function ajax(url, method)&#123; var xhr = getXHR(); xhr.onreadystatechange = function()&#123; console.log(&apos;xhr.readyState:&apos; + this.readyState); &#125; xhr.onloadstart = function()&#123; console.log(&apos;onloadStart&apos;); &#125; xhr.onload = function()&#123; console.log(&apos;onload&apos;); &#125; xhr.open(method, url, true); xhr.setRequestHeader(&apos;Cache-Control&apos;,3600); xhr.send();&#125;ajax(&apos;http://louiszhai.github.io/docImages/ajax01.png&apos;,&apos;GET&apos;);console.warn(&apos;这里的log并不是最先打印出来的.&apos;);12345678910111213141516171819202122232425262728 上述代码执行结果如下图: 由于ajax异步, setTimeout及Promise本应该最先被执行, 然而实际上, 一次ajax请求, 并非所有的部分都是异步的, 至少”readyState==1”的 onreadystatechange 回调以及 onloadstart 回调就是同步执行的. 因此它们的输出排在最前面. XMLHttpRequest 属性解读首先在Chrome console下创建一个 XMLHttpRequest 实例对象xhr. 如下所示: inherit试运行以下代码. 12345678910var xhr = new XMLHttpRequest(), i=0;for(var key in xhr)&#123; if(xhr.hasOwnProperty(key))&#123; i++; &#125;&#125;console.log(i);//0console.log(XMLHttpRequest.prototype.hasOwnProperty(&apos;timeout&apos;));//true123456789 可见, XMLHttpRequest 实例对象没有自有属性. 实际上, 它的所有属性均来自于 XMLHttpRequest.prototype . 追根溯源, XMLHttpRequest 实例对象具有如下的继承关系. (下面以a&lt;&lt;b表示a继承b) xhr &lt;&lt; XMLHttpRequest.prototype &lt;&lt; XMLHttpRequestEventTarget.prototype &lt;&lt; EventTarget.prototype &lt;&lt; Object.prototype 由上, xhr也具有Object等原型中的所有方法. 如toString方法. 12xhr.toString();//&quot;[object XMLHttpRequest]&quot;1 通常, 一个xhr实例对象拥有10个普通属性+9个方法. readyState只读属性, readyState属性记录了ajax调用过程中所有可能的状态. 它的取值简单明了, 如下: readyState 对应常量 描述 0 (未初始化) xhr.UNSENT 请求已建立, 但未初始化(此时未调用open方法) 1 (初始化) xhr.OPENED 请求已建立, 但未发送 (已调用open方法, 但未调用send方法) 2 (发送数据) xhr.HEADERS_RECEIVED 请求已发送 (send方法已调用, 已收到响应头) 3 (数据传送中) xhr.LOADING 请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误 4 (完成) xhr.DONE 数据接收完毕, 此时可以通过通过responseBody和responseText获取完整的响应数据 注意, readyState 是一个只读属性, 想要改变它的值是不可行的. onreadystatechangeonreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调, 比如: 12345678910xhr.onreadystatechange = function(e)&#123; if(xhr.readyState==4)&#123; var s = xhr.status; if((s &gt;= 200 &amp;&amp; s &lt; 300) || s == 304)&#123; var resp = xhr.responseText; //TODO ... &#125; &#125;&#125;123456789 注意: onreadystatechange回调中默认会传入Event实例, 如下: status只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200. statusText只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 OK . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 Moved Permanently , 302的 Found , 303的 See Other , 307 的 Temporary Redirect , 400的 Bad Request , 401的 Unauthorized 等等. onloadstartonloadstart事件回调方法在ajax请求发送之前触发, 触发时机在 readyState==1 状态之后, readyState==2 状态之前. onloadstart方法中默认将传入一个ProgressEvent事件进度对象. 如下: ProgressEvent对象具有三个重要的Read only属性. lengthComputable 表示长度是否可计算, 它是一个布尔值, 初始值为false. loaded 表示已加载资源的大小, 如果使用http下载资源, 它仅仅表示已下载内容的大小, 而不包括http headers等. 它是一个无符号长整型, 初始值为0. total 表示资源总大小, 如果使用http下载资源, 它仅仅表示内容的总大小, 而不包括http headers等, 它同样是一个无符号长整型, 初始值为0. onprogressonprogress事件回调方法在 readyState==3 状态时开始触发, 默认传入 ProgressEvent 对象, 可通过 e.loaded/e.total 来计算加载资源的进度, 该方法用于获取资源的下载进度. 注意: 该方法适用于 IE10+ 及其他现代浏览器. 1234xhr.onprogress = function(e)&#123; console.log(&apos;progress:&apos;, e.loaded/e.total);&#125;123 onloadonload事件回调方法在ajax请求成功后触发, 触发时机在 readyState==4 状态之后. 想要捕捉到一个ajax异步请求的成功状态, 并且执行回调, 一般下面的语句就足够了: 12345678xhr.onload = function()&#123; var s = xhr.status; if((s &gt;= 200 &amp;&amp; s &lt; 300) || s == 304)&#123; var resp = xhr.responseText; //TODO ... &#125;&#125;1234567 onloadendonloadend事件回调方法在ajax请求完成后触发, 触发时机在 readyState==4 状态之后(收到响应时) 或者 readyState==2 状态之后(未收到响应时). onloadend方法中默认将传入一个ProgressEvent事件进度对象. timeouttimeout属性用于指定ajax的超时时长. 通过它可以灵活地控制ajax请求时间的上限. timeout的值满足如下规则: 通常设置为0时不生效. 设置为字符串时, 如果字符串中全部为数字, 它会自动将字符串转化为数字, 反之该设置不生效. 设置为对象时, 如果该对象能够转化为数字, 那么将设置为转化后的数字. 123456xhr.timeout = 0; //不生效xhr.timeout = &apos;123&apos;; //生效, 值为123xhr.timeout = &apos;123s&apos;; //不生效xhr.timeout = [&apos;123&apos;]; //生效, 值为123xhr.timeout = &#123;a:123&#125;; //不生效12345 ontimeoutontimeout方法在ajax请求超时时触发, 通过它可以在ajax请求超时时做一些后续处理. 1234xhr.ontimeout = function(e) &#123; console.error(&quot;请求超时!!!&quot;)&#125;123 response responseText均为只读属性, response表示服务器的响应内容, 相应的, responseText表示服务器响应内容的文本形式. responseXML只读属性, responseXML表示xml形式的响应数据, 缺省为null, 若数据不是有效的xml, 则会报错. responseTyperesponseType表示响应的类型, 缺省为空字符串, 可取 &quot;arraybuffer&quot; , &quot;blob&quot; , &quot;document&quot; , &quot;json&quot; , and &quot;text&quot; 共五种类型. responseURLresponseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL. withCredentialswithCredentials是一个布尔值, 默认为false, 表示跨域请求中不发送cookies等信息. 当它设置为true时, cookies , authorization headers 或者TLS客户端证书 都可以正常发送和接收. 显然它的值对同域请求没有影响. 但是务必要注意，withCredentials属性什么时机设置，XMLHttpRequest Living Standard（2017）中有明确的规定。 Setting the withCredentials attribute must run these steps: If state is not unsent or opened, throw an InvalidStateError exception. If the send() flag is set, throw an InvalidStateError exception. Set the withCredentials attribute’s value to the given value. 这意味着，readyState为unset或者opened之前，是不能为xhr对象设置withCredentials属性的，实际上，新建的xhr对象，默认就是unset状态，因此这里没有问题。问题出在w3c 2011年的规范，当时是这么描述的： On setting the withCredentials attribute these steps must be run: If the state is not OPENED raise an INVALID_STATE_ERR exception and terminate these steps. If the send() flag is true raise an INVALID_STATE_ERR exception and terminate these steps. If the anonymous flag is true raise an INVALID_ACCESS_ERR exception and terminate these steps. Set the withCredentials attribute’s value to the given value. 注意第一条，readyState为unset之前，为xhr对象设置withCredentials属性就会抛出INVALID_STATE_ERR错误。 目前，一些老的浏览器或webview仍然是参考w3c 2011年的规范，因此为了兼容，建议在readyState为opened状态之后才去设置withCredentials属性。 之前zepto.js就踩过这个坑，感兴趣不妨阅读前方有坑，请绕道——Zepto 中使用 CORS。 注意: 该属性适用于 IE10+, opera12+及其他现代浏览器。Android 4.3及以下版本的webview，采用的是w3c 2011的规范，请务必在open方法调用之后再设置withCredentials的值。 abortabort方法用于取消ajax请求, 取消后, readyState 状态将被设置为 0 (UNSENT). 如下, 调用abort 方法后, 请求将被取消. getResponseHeadergetResponseHeader方法用于获取ajax响应头中指定name的值. 如果response headers中存在相同的name, 那么它们的值将自动以字符串的形式连接在一起. 12console.log(xhr.getResponseHeader(&apos;Content-Type&apos;));//&quot;text/html&quot;1 getAllResponseHeadersgetAllResponseHeaders方法用于获取所有安全的ajax响应头, 响应头以字符串形式返回. 每个HTTP报头名称和值用冒号分隔, 如key:value, 并以\r\n结束. 1234567xhr.onreadystatechange = function() &#123; if(this.readyState == this.HEADERS_RECEIVED) &#123; console.log(this.getAllResponseHeaders()); &#125;&#125;//Content-Type: text/html&quot;123456 以上, readyState === 2 状态时, 就意味着响应头已接受完整. 此时便可以打印出完整的 response headers. setRequestHeader既然可以获取响应头, 那么自然也可以设置请求头, setRequestHeader就是干这个的. 如下: 12345//指定请求的type为json格式xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;);//除此之外, 还可以设置其他的请求头xhr.setRequestHeader(&apos;x-requested-with&apos;, &apos;123456&apos;);1234 onerroronerror方法用于在ajax请求出错后执行. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时触发(如果请求返回的是407状态码, chrome下也会触发onerror). uploadupload属性默认返回一个 XMLHttpRequestUpload 对象, 用于上传资源. 该对象具有如下方法: onloadstart onprogress onabort onerror onload ontimeout onloadend 上述方法功能同 xhr 对象中同名方法一致. 其中, onprogress 事件回调方法可用于跟踪资源上传的进度. 12345xhr.upload.onprogress = function(e)&#123; var percent = 100 * e.loaded / e.total |0; console.log(&apos;upload: &apos; + precent + &apos;%&apos;);&#125;1234 overrideMimeTypeoverrideMimeType方法用于强制指定response 的 MIME 类型, 即强制修改response的 Content-Type . 如下, 服务器返回的response的 MIME 类型为 text/plain . 123xhr.getResponseHeader(&apos;Content-Type&apos;);//&quot;text/plain&quot;xhr.responseXML;//null12 通过overrideMimeType方法将response的MIME类型设置为 text/xml;charset=utf-8 , 如下所示: 123xhr.overrideMimeType(&quot;text/xml; charset = utf-8&quot;);xhr.send();12 此时虽然 response headers 如上图, 没有变化, 但 Content-Type 已替换为新值. 12xhr.getResponseHeader(&apos;Content-Type&apos;);//&quot;text/xml; charset = utf-8&quot;1 此时, xhr.responseXML 也将返回DOM对象, 如下图. XHR一级XHR1 即 XMLHttpRequest Level 1. XHR1时, xhr对象具有如下缺点: 仅支持文本数据传输, 无法传输二进制数据. 传输数据时, 没有进度信息提示, 只能提示是否完成. 受浏览器 同源策略 限制, 只能请求同域资源. 没有超时机制, 不方便掌控ajax请求节奏. XHR二级XHR2 即 XMLHttpRequest Level 2. XHR2针对XHR1的上述缺点做了如下改进: 支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单. 提供进度提示, 可通过 xhr.upload.onprogress 事件回调方法获取传输进度. 依然受 同源策略 限制, 这个安全机制不会变. XHR2新提供 Access-Control-Allow-Origin 等headers, 设置为 * 时表示允许任何域名请求, 从而实现跨域CORS访问(有关CORS详细介绍请耐心往下读). 可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理. 这里就H5新增的FormData对象举个例. 12345678910//可直接创建FormData实例var data = new FormData();data.append(&quot;name&quot;, &quot;louis&quot;);xhr.send(data);//还可以通过传入表单DOM对象来创建FormData实例var form = document.getElementById(&apos;form&apos;);var data = new FormData(form);data.append(&quot;password&quot;, &quot;123456&quot;);xhr.send(data);123456789 目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的. 那么问题来了, IE7, 8,9的用户怎么办? 很遗憾, 这些用户是比较尴尬的. 对于IE8,9而言, 只有一个阉割版的 XDomainRequest 可用,IE7则没有. 估计IE7用户只能哭晕在厕所了. XDomainRequestXDomainRequest 对象是IE8,9折腾出来的, 用于支持CORS请求非成熟的解决方案. 以至于IE10中直接移除了它, 并重新回到了 XMLHttpRequest 的怀抱. XDomainRequest 仅可用于发送 GET和 POST 请求. 如下即创建过程. 12var xdr = new XDomainRequest();1 xdr具有如下属性: timeout responseText 如下方法: open: 只能接收Method,和url两个参数. 只能发送异步请求. send abort 如下事件回调: onprogress ontimeout onerror onload 除了缺少一些方法外, XDomainRequest 基本上就和 XMLHttpRequest 的使用方式保持一致. 必须要明确的是: XDomainRequest 不支持跨域传输cookie. 只能设置请求头的Content-Type字段, 且不能访问响应头信息. $.ajax$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要. 参数列表$.ajax() 只有一个参数, 该参数为key-value设置对象. 实际上, jq发送的所有ajax请求, 都是通过调用该ajax方法实现的. 它的详细参数如下表: 序号 参数 类型 描述 1 accepts PlainObject 用于通知服务器该请求需要接收何种类型的返回结果. 如有必要, 推荐在 $.ajaxSetup() 方法中设置一次. 2 async Boolean 默认为true, 即异步. 3 beforeSend Function 请求发送前的回调, 默认传入参数jqXHR和settings. 函数内显式返回false将取消本次请求. 4 cache Boolean 请求是否开启缓存, 默认为true, 如不需要缓存请设置为false. 不过, dataType为”script”和”jsonp”时默认为false. 5 complete Function 请求完成后的回调(请求success 和 error之后均调用), 默认传入参数jqXHR和textStatus(请求状态, 取值为 “success”,”notmodified”,”error”,”timeout”,”abort”,”parsererror”之一). 从jq1.5开始, complete可以设置为一个包含函数的数组. 如此每个函数将依次被调用. 6 contents PlainObject 一个以”{字符串/正则表达式}”配对的对象, 根据给定的内容类型, 解析请求的返回结果. 7 contentType String 编码类型, 相对应于http请求头域的”Content-Type”字段. 默认值为”application/x-www-form-urlencoded; charset=UTF-8”. 8 context Object 设置ajax回调函数的上下文. 默认上下文为ajax请求传入的参数设置对象. 如设置为document.body, 那么所有ajax回调函数中将以body为上下文. 9 converters PlainObject 一个数据类型到数据类型转换器的对象. 默认为 {&quot;* text&quot;: window.String, &quot;text html&quot;: true, &quot;text json&quot;: jQuery.parseJSON, &quot;text xml&quot;: jQuery.parseXML} . 如设置converters:{&quot;json jsonp&quot;: function(msg){}} 10 crossDomain Boolean 默认同域请求为false, 跨域请求为true. 11 data Object, Array 发送到服务器的数据, 默认data为键值对格式对象, 若data为数组则按照traditional参数的值, 自动转化为一个同名的多值查询字符串. 如{a:1,b:2}将转换为”&amp;a=1&amp;b=2”. 12 dataFilter Function 处理XMLHttpRequest原始响应数据的回调, 默认传入data和type参数, data是Ajax返回的原始数据, type是调用$.ajax时提供的dataType参数 13 dataType String 预期服务器返回的数据类型, 可设置为”xml”,”html”,”script”,”json”,”jsonp”,”text”之一, 其中设置为”xml”或”text”类型时, 数据不会经过处理. 14 error Function 请求失败时的回调函数, 默认传入jqXHR(jq1.4以前为原生xhr对象),textStatus(请求状态,取值为null,”timeout”,”error”,”abort” 或 “parsererror”),errorString(错误内容), 当一个HTTP错误发生时, errorThrown 接收HTTP状态的文本部分,比如”Not Found”等. 从jq1.5开始, error可以设置为一个包含函数的数组. 如此每个函数将依次被调用.注意: 跨域脚本和JSONP请求时error不被调用. 15 global Boolean 表示是否触发全局ajax事件, 默认为true. 设为false将不再触发ajaxStart,ajaxStop,ajaxSend,ajaxError等. 跨站脚本和jsonp请求, 该值自动设置为false. 16 headers PlainObject 设置请求头, 格式为k-v键值对对象. 由于该设置会在beforeSend函数被调用之前生效, 因此可在beforeSend函数内覆盖该对象. 17 ifModified Boolean 只有上次请求响应改变时, 才允许请求成功. 它使用HTTP包的Last-Modified 头信息判断, 默认为false. 若设置为true, 且数据自从上次请求后没有更改过就会报错. 18 isLocal Boolean 运行当前环境设置为”本地”,默认为false, 若设置为true, 将影响请求发送时的协议. 19 jsonp String 显式指定jsonp请求中的回调函数的名称. 如jsonp:cb, jq会将cb代替callback, 以 “cb=?”传给服务器. 从jq1.5开始, 若设置jsonp:false, 那么需要明确设置jsonpCallback:”callbackName”. 20 jsonpCallback String,Function 为jsonp请求指定一个回调函数名, 以取代jq自动生成的随机函数名. 从jq1.5开始, 可以将该属性设置为一个函数, 函数的返回值就是jsonpCallback的结果. 21 mimeType String 设置一个MIME类型, 以覆盖xhr的MIM类型(jq1.5新增) 22 password String 设置认证请求中的密码 23 processData Boolean jq的ajax方法默认会将传入的data隐式转换为查询字符串(如”&amp;a=1&amp;b=2”), 以配合 默认内容类型 “application/x-www-form-urlencoded”, 如果不希望转换请设置为false. angular中想要禁用默认转换, 需要重写transformRequest方法. 24 scriptCharset String 仅在”script”请求中使用(如跨域jsonp, dataType为”script”类型). 显式指定时, 请求中将在script标签上设置charset属性, 可在发现本地和远程编码不一致时使用. 25 statusCode PlainObject 一组http状态码和回调函数对应的键值对对象. 该对象以 {404:function(){}} 这种形式表示. 可用于根据不同的http状态码, 执行不同的回调.(jq1.5新增) 26 timeout Number 设置超时时间. 27 traditional Boolean 是否按照默认方式序列化data对象, 默认值为false. 28 type String 可以设置为8种http method之一, jq中不区分大小写. 29 url String 请求的uri地址. 30 username String 设置认证请求中的用户名 31 xhr Function 在回调内创建并返回xhr对象 32 xhrFields PlainObject 键值对对象, 用于设置原生的xhr对象, 如可用来设置withCredentials:true(jq1.5.1新增) 支持promise$.ajax() 方法返回jqXHR对象(jq1.5起), 如果使用的不是XMLHttpRequest对象时, 如jsonp请求, 返回的jqXHR对象将尽可能模拟原生的xhr. 从jq1.5起, 返回的jqXHR对象实现了promise接口, 具有如下新方法. 新方法 被替代的老方法(jq1.8起弃用) done(function(data, textStatus, jqXHR) {}) success fail(function(jqXHR, textStatus, errorThrown) {}) error always(function(data or jqXHR, textStatus, jqXHR or errorThrown) {}) complete 从jq1.6开始, done, fail, always按照FIFO队列可以分配多个回调. 使用转换器$.ajax() 的转换器可以将支持的数据类型映射到其它数据类型. 如果需要将自定义数据类型映射到已知的类型. 需要使用 contents 选项在响应的 “Content-Type” 和实际数据类型之间添加一个转换函数. 123456789101112$.ajaxSetup(&#123; contents: &#123; myContentType: /myContentType/ &#125;, converters: &#123; &quot;myContentType json&quot;: function(data) &#123; //TODO something return newData; &#125; &#125;&#125;);1234567891011 转换一个支持的类型为自定义类型, 然后再返回. 如 text—&gt;myContentType—&gt;json. 12345678910111213$.ajaxSetup(&#123; contents: &#123; myContentType: /myContentType/ &#125;, converters: &#123; &quot;text myContentType&quot;: true, &quot;myContentType json&quot;: function(data) &#123; //TODO something return newData; &#125; &#125;&#125;);123456789101112 事件触发顺序$.ajax()方法触发的事件纷繁复杂, 有将近20个之多. 为了囊括最多的事件, 这里以一次成功的上传请求为例, 以下是它们的调用顺序(请求出现错误时的顺序, 请自行对应). 序号 事件名称 是否全局事件 是否能关闭 默认形参 1 $.ajaxPrefilter ✔️ ❌ function(options, originalOptions, jqXHR){} 2 $(document).ajaxStar ✔️ ✔️ function(){}(只在当前无激活ajax时触发) 3 beforeSend ❌ - function(jqXHR, settings){} 4 $(document).ajaxSend ✔️ ✔️ function(){} 5 xhr.onloadstart - - ProgressEvent 6 xhr.upload.onloadstart - - ProgressEvent 7 xhr.upload.onprogress - - ProgressEvent 8 xhr.upload.onload - - ProgressEvent 9 xhr.upload.onloadend - - ProgressEvent 10 xhr.onprogress - - ProgressEvent 11 xhr.onload - - ProgressEvent 12 success(弃用) ❌ - function(data, textStatus, jqXHR){} 13 $(document).ajaxSuccess ✔️ ✔️ function(event, jqXHR, options){} 14 complete(弃用) ❌ - function(jqXHR, textStatus){} 15 $(document).ajaxComplete ✔️ ✔️ function(event, jqXHR, textStatus) 16 $(document).ajaxStop ✔️ ✔️ function(){} 17 xhr.onloadend - - ProgressEvent 从jq1.8起, 对于函数 ajaxStart, ajaxSend, ajaxSuccess, ajaxComplete, ajaxStop , 只能为document对象绑定事件处理函数, 为其他元素绑定的事件处理函数不会起作用. Axios实际上, 如果你仅仅只是想要一个不错的http库, 相比于庞大臃肿的jquery, 短小精悍的Axios可能更加适合你. 原因如下: Axios支持node, jquery并不支持. Axios基于promise语法, jq3.0才开始全面支持. Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢. vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话. “最近团队讨论了一下, Ajax 本身跟 Vue 并没有什么需要特别整合的地方, 使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果, vue-resource 提供的价值和其维护成本相比并不划算, 所以决定在不久以后取消对 vue-resource 的官方推荐.” Axios大小仅12k, 目前最新版本号为: 语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下: 12345678axios.get(&quot;https://api.github.com/users/louiszhai&quot;) .then(function(response)&#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);1234567 除了get, 它还支持post, delete, head, put, patch, request请求. 具体使用攻略, 请戳这里: axios . 如需在网页上引入 Axios, 可以链接CDN axios | Bootstrap中文网开源项目免费 CDN 服务 或者将其下载到本地. Fetch说到ajax, 就不得不提及fetch, 由于篇幅较长, fetch已从本文中独立出来, 请戳 Fetch进阶指南 . ajax跨域请求什么是CORSCORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外) 通常, 一次跨域访问拥有如下流程: 移动端CORS兼容性当前几乎所有的桌面浏览器(Internet Explorer 8+, Firefox 3.5+, Safari 4+和 Chrome 3+)都可通过名为跨域资源共享的协议支持ajax跨域调用. 那么移动端兼容性又如何呢? 请看下图: 可见, CORS的技术在IOS Safari7.1及Android webview2.3中就早已支持, 即使低版本下webview的canvas在使用跨域的video或图片时会有问题, 也丝毫不影响CORS的在移动端的使用. 至此, 我们就可以放心大胆的去应用CORS了. CORS有关的headers1) HTTP Response Header(服务器提供): Access-Control-Allow-Origin: 指定允许哪些源的网页发送请求. Access-Control-Allow-Credentials: 指定是否允许cookie发送. Access-Control-Allow-Methods: 指定允许哪些请求方法. Access-Control-Allow-Headers: 指定允许哪些常规的头域字段, 比如说 Content-Type. Access-Control-Expose-Headers: 指定允许哪些额外的头域字段, 比如说 X-Custom-Header. 该字段可省略. CORS请求时, xhr.getResponseHeader() 方法默认只能获取6个基本字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma . 如果需要获取其他字段, 就需要在Access-Control-Expose-Headers 中指定. 如上, 这样xhr.getResponseHeader(‘X-Custom-Header’) 才能返回X-Custom-Header字段的值.(该部分摘自阮一峰老师博客) Access-Control-Max-Age: 指定preflight OPTIONS请求的有效期, 单位为秒. 2) HTTP Request Header(浏览器OPTIONS请求默认自带): Access-Control-Request-Method: 告知服务器,浏览器将发送哪种请求, 比如说POST. Access-Control-Request-Headers: 告知服务器, 浏览器将包含哪些额外的头域字段. 3) 以下所有的header name 是被拒绝的: Accept-Charset Accept-Encoding Access-Control-Request-Headers Access-Control-Request-Method Connection Content-Length Cookie Cookie2 Date DNT Expect Host Keep-Alive Origin Referer TE Trailer Transfer-Encoding Upgrade Via 包含以Proxy- 或 Sec- 开头的header name CORS请求CORS请求分为两种, ① 简单请求; ② 非简单请求. 满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客) 1) 请求是以下三种之一: HEAD GET POST 2) http头域不超出以下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type字段限三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 Origin 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 Access-Control-* 等字段.( Access-Control-* 相关字段解析请阅读我之前写的CORS 跨域访问 ) 对于非简单请求, 比如Method为POST且Content-Type值为 application/json 的请求或者Method为 PUT 或 DELETE 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 Access-Control-* 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发). 以上请求流程图为: HTML启用CORShttp-equiv 相当于http的响应头, 它回应给浏览器一些有用的信息,以帮助正确和精确地显示网页内容. 如下html将允许任意域名下的网页跨域访问. 12&lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;1 图片启用CORS通常, 图片允许跨域访问, 也可以在canvas中使用跨域的图片, 但这样做会污染画布, 一旦画布受污染, 将无法读取其数据. 比如无法调用 toBlob(), toDataURL() 或 getImageData()方法. 浏览器的这种安全机制规避了未经许可的远程服务器图片被滥用的风险.(该部分内容摘自 启用了 CORS 的图片 - HTML（超文本标记语言） | MDN) 因此如需在canvas中使用跨域的图片资源, 请参考如下apache配置片段(来自HTML5 Boilerplate Apache server configs). 123456789&lt;IfModule mod_setenvif.c&gt; &lt;IfModule mod_headers.c&gt; &lt;FilesMatch &quot;\.(cur|gif|ico|jpe?g|png|svgz?|webp)$&quot;&gt; SetEnvIf Origin &quot;:&quot; IS_CORS Header set Access-Control-Allow-Origin &quot;*&quot; env=IS_CORS &lt;/FilesMatch&gt; &lt;/IfModule&gt;&lt;/IfModule&gt;12345678 ajax文件上传ajax实现文件上传非常简单, 这里我选取原生js, jq, angular 分别来比较下, 并顺便聊聊使用它们时的注意事项.(ajax文件上传的代码已上传至github, 请戳这里预览效果: ajax 文件上传 demo | louis) 1) 为了上传文件, 我们得先选中一个文件. 一个type为file的input框就够了. 12&lt;input id=&quot;input&quot; type=&quot;file&quot;&gt;1 2) 然后用FormData对象包裹📦选中的文件. 1234var input = document.getElementById(&quot;input&quot;), formData = new FormData();formData.append(&quot;file&quot;,input.files[0]);//key可以随意定义,只要后台能理解就行123 3) 定义上传的URL, 以及方法. github上我搭建了一个 node-webserver, 根据需要可以自行克隆下来npm start后便可调试本篇代码. 123var url = &quot;http://localhost:10108/test&quot;, method = &quot;POST&quot;;12 js文件上传4.1) 封装一个用于发送ajax请求的方法. 1234567891011121314151617181920212223242526272829function ajax(url, method, data)&#123; var xhr = null; if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e) &#123; alert(&quot;您的浏览器暂不支持Ajax!&quot;); &#125; &#125; &#125; xhr.onerror = function(e)&#123; console.log(e); &#125; xhr.open(method, url); try&#123; setTimeout(function()&#123; xhr.send(data); &#125;); &#125;catch(e)&#123; console.log(&apos;error:&apos;,e); &#125; return xhr;&#125;12345678910111213141516171819202122232425262728 4.2) 上传文件并绑定事件. 1234567891011var xhr = ajax(url, method, formData);xhr.upload.onprogress = function(e)&#123; console.log(&quot;upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;);&#125;;xhr.upload.onload = function()&#123; console.log(&quot;upload onload.&quot;);&#125;;xhr.onload = function()&#123; console.log(&quot;onload.&quot;);&#125;12345678910 上传结果如下所示: fetch上传5) fetch只要发送一个post请求, 并且body属性设置为formData即可. 遗憾的是, fetch无法跟踪上传的进度信息. 123456789fetch(url, &#123; method: method, body: formData &#125;).then(function(res)&#123; console.log(res); &#125;).catch(function(e)&#123; console.log(e);&#125;);12345678 jquery文件上传jq提供了各式各样的上传插件, 其原理都是利用jq自身的ajax方法. 6) jq的ajax提供了xhr属性用于自定义各种事件. 1234567891011121314151617181920212223$.ajax(&#123; type: method, url: url, data: formData, processData : false, contentType : false ,//必须false才会自动加上正确的Content-Type xhr: function()&#123; var xhr = $.ajaxSettings.xhr();//实际上就是return new window.XMLHttpRequest()对象 if(xhr.upload) &#123; xhr.upload.addEventListener(&quot;progress&quot;, function(e)&#123; console.log(&quot;jq upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;); &#125;, false); xhr.upload.addEventListener(&quot;load&quot;, function()&#123; console.log(&quot;jq upload onload.&quot;); &#125;); xhr.addEventListener(&quot;load&quot;, function()&#123; console.log(&quot;jq onload.&quot;); &#125;); return xhr; &#125; &#125;&#125;);12345678910111213141516171819202122 jq上传结果如下所示: 有关jq ajax更多的api, 请参考中文文档 jQuery.ajax() | jQuery API 中文文档 . angular文件上传7.1) angular提供了$http方法用于发送http请求, 该方法返回一个promise对象. 12345678910$http(&#123; method: method, url: url, data: formData,&#125;).success(function(res) &#123; console.log(res);&#125;).error(function(err, status) &#123; console.log(err);&#125;);123456789 angular文件上传的代码已上传至github, 请戳这里预览效果: angular 文件上传 demo | louis. 低版本angular中文件上传的功能并不完整, 直到angular1.5.5才在$http中加入了eventHandler和uploadEventHandlers等方法, 使得它支持上传进度信息. 如下: 1234567891011121314151617181920$http(&#123; method: method, url: url, eventHandlers: &#123; progress: function(c) &#123;//下载进度 console.log(&apos;Progress -&gt; &apos; + c); &#125; &#125;, uploadEventHandlers: &#123; progress: function(e) &#123;//上传进度 console.log(&apos;UploadProgress -&gt; &apos; + e); &#125; &#125;, data: formData,&#125;).success(function(res) &#123; console.log(res);&#125;).error(function(err, status) &#123; console.log(err);&#125;);12345678910111213141516171819 angular1.5.5以下低版本中, 请参考成熟的实现方案 angular-file-upload 以及它提供的demo Simple example . ajax请求二进制文件FileReader处理二进制文件主要使用的是H5的FileReader. PC支持性如下: IE Edge Firefox Chrome Safari Opera 10 12 3.6 6 6 11.5 Mobile支持性如下: IOS Safari Opera Mini Android Browser Chrome/Android UC/Android 7.1 - 4 53 11 以下是其API: 属性/方法名称 描述 error 表示读取文件期间发生的错误. readyState 表示读取文件的状态.默认有三个值:0表示文件还没有加载;1表示文件正在读取;2表示文件读取完成. result 读取的文件内容. abort() 取消文件读取操作, 此时readyState属性将置为2. readAsArrayBuffer() 读取文件(或blob对象)为类型化数组(ArrayBuffer), 类型化数组允许开发者以数组下标的方式, 直接操作内存, 由于数据以二进制形式传递, 效率非常高. readAsBinaryString() 读取文件(或blob对象)为二进制字符串, 该方法已移出标准api, 请谨慎使用. readAsDataURL() 读取文件(或blob对象)为base64编码的URL字符串, 与window.URL.createObjectURL方法效果类似. readAsText() 读取文件(或blob对象)为文本字符串. onload() 文件读取完成时的事件回调, 默认传入event事件对象. 该回调内, 可通过this.result 或 event.target.result获取读取的文件内容. ajax请求二进制图片并预览1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest(), url = &quot;http://louiszhai.github.io/docImages/ajax01.png&quot;;xhr.open(&quot;GET&quot;, url);xhr.responseType = &quot;blob&quot;;xhr.onload = function()&#123; if(this.status == 200)&#123; var blob = this.response; var img = document.createElement(&quot;img&quot;); //方案一 img.src = window.URL.createObjectURL(blob);//这里blob依然占据着内存 img.onload = function() &#123; window.URL.revokeObjectURL(img.src);//释放内存 &#125;; //方案二 /*var reader = new FileReader(); reader.readAsDataURL(blob);//FileReader将返回base64编码的data-uri对象 reader.onload = function()&#123; img.src = this.result; &#125;*/ //方案三 //img.src = url;//最简单方法 document.body.appendChild(img); &#125;&#125;xhr.send();12345678910111213141516171819202122232425 ajax请求二进制文本并展示123456789101112131415var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;,&quot;http://localhost:8080/Information/download.jsp?data=node-fetch.js&quot;);xhr.responseType = &quot;blob&quot;;xhr.onload = function()&#123; if(this.status == 200)&#123; var blob = this.response; var reader = new FileReader(); reader.readAsBinaryString(blob);//该方法已被移出标准api,建议使用reader.readAsText(blob); reader.onload=function()&#123; document.body.innerHTML = &quot;&lt;div&gt;&quot; + this.result + &quot;&lt;/div&gt;&quot;; &#125; &#125;&#125;xhr.send();1234567891011121314 有关二进制文件的读取, 请移步这篇博客 HTML5新特性之文件和二进制数据的操作 . 如何等待多个ajax请求完成原生js可以使用ES6新增的Promise. ES6的Promise基于 Promises/A+ 规范(该部分 Fetch入门指南 一文也有提及). 这里先提供一个解析responses的函数. 12345678function todo(responses)&#123; responses.forEach(function(response)&#123; response.json().then(function(res)&#123; console.log(res); &#125;); &#125;);&#125;1234567 原生js使用 Promise.all 方法. 如下: 123456789var p1 = fetch(&quot;http://localhost:10108/test1&quot;), p2 = fetch(&quot;http://localhost:10108/test2&quot;);Promise.all([p1, p2]).then(function(responses)&#123; todo(responses); //TODO do somethings&#125;);//&quot;test1&quot;//&quot;test2&quot;12345678 jquery可以使用$.when方法. 该方法接受一个或多个Deferred对象作为参数, 只有全部成功才调用resolved状态的回调函数, 但只要其中有一个失败，就调用rejected状态的回调函数. 其实, jq的Deferred是基于 Promises/A规范实现, 但并非完全遵循. (传送门: jQuery 中的 Deferred 和 Promises (2) ). 12345678var p1 = $.ajax(&quot;http://localhost:10108/test1&quot;), p2 = $.ajax(&quot;http://localhost:10108/test2&quot;);$.when(p1, p2).then(function(res1, res2)&#123; console.log(res1);//[&quot;test1&quot;, &quot;success&quot;, Object] console.log(res2);//[&quot;test2&quot;, &quot;success&quot;, Object] //TODO do somethings&#125;);1234567 如上, $.when默认返回一个jqXHR对象, 可以直接进行链式调用. then方法的回调中默认传入相应的请求结果, 每个请求结果的都是数组, 数组中依次是responseText, 请求状态, 请求的jqXHR对象. angular中可以借助 $q.all() 来实现. 别忘了, $q 需要在controller中注入. 此外, $q 相关讲解可参考 AngularJS: ng.$q 或 Angular $q service学习笔记 . 123456789var p1 = fetch(&quot;http://localhost:10108/test1&quot;), p2 = fetch(&quot;http://localhost:10108/test2&quot;);$q.all([p1, p2]).then(function(responses)&#123; todo(responses); //TODO do somethings&#125;);//&quot;test1&quot;//&quot;test2&quot;12345678 $q.all() 实际上就是对 Promise.all 的封装. ajax与history的兼容ajax的一大痛点就是无法支持浏览器前进和后退操作. 因此早期的Gmail 采用 iframe, 来模拟ajax的前进和后退. 如今, H5普及, pjax大行其道. pajax 就是 ajax+history.pushState 组合的一种技术. 使用它便可以无刷新通过浏览器前进和后退来改变页面内容. 先看下兼容性. IE Edge Firefox Chrome Safari Opera iOS Safari Android Browser Chrome for Android pushState/replaceState 10 12 4 5 6 11.5 7.1 4.3 53 history.state 10 4 18 6 11.5 可见IE8,9并不能使用 H5的history. 需要使用垫片 HTML5 History API expansion for browsers not supporting pushState, replaceState . pjaxpjax简单易用, 仅需要如下三个api: history.pushState(obj, title, url) 表示往页面history末尾新增一个历史项(history entry), 此时history.length会+1. history.replaceState(obj, title, url) 表示替换当前历史项为新的历史项. 此时history.length保持不变. window.onpopstate 仅在浏览器前进和后退时触发(history.go(1), history.back() 及location.href=”xxx” 均会触发), 此时可在history.state中拿到刚刚塞进去的state, 即obj对象(其他数据类型亦可). 我们注意到, 首次进入一个页面, 此时 history.length 值为1, history.state 为空. 如下: 1) 为了在onpopstate事件回调中每次都能拿到 history.state , 此时需要在页面载入完成后, 自动替换下当前url. 12history.replaceState(&quot;init&quot;, title, &quot;xxx.html?state=0&quot;);1 2) 每次发送ajax请求时, 在请求完成后, 调用如下, 从而实现浏览器history往前进. 12history.pushState(&quot;ajax请求相关参数&quot;, title, &quot;xxx.html?state=标识符&quot;);1 3) 浏览器前进和后退时, popstate 事件会自动触发, 此时我们手动取出 history.state , 构建参数并重新发送ajax请求或者直接取用state值, 从而实现无刷新还原页面. 123456window.addEventListener(&quot;popstate&quot;, function(e) &#123; var currentState = history.state; //TODO 拼接ajax请求参数并重新发送ajax请求, 从而回到历史页面 //TODO 或者从state中拿到关键值直接还原历史页面&#125;);12345 popstate 事件触发时, 默认会传入 PopStateEvent 事件对象. 该对象具有如下属性. 如有不懂, 更详细讲解请移步 : ajax与HTML5 history pushState/replaceState实例 « 张鑫旭-鑫空间-鑫生活 . ajax缓存处理js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存. 1234xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;);xhr.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//或者 URL 参数后加上 &quot;?timestamp=&quot; + new Date().getTime()123 jquery的http缓存是否开启可通过在settings中指定cache. 12345678$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;xml&quot;, cache: true,//true表示缓存开启, false表示缓存不开启 success : function(xml, status)&#123; &#125;&#125;);1234567 同时jquery还可以全局设置是否缓存. 如下将全局关闭ajax缓存. 12$.ajaxSetup(&#123;cache:false&#125;);1 除此之外, 调试过程中出现的浏览器缓存尤为可恶. 建议开启隐私浏览器或者勾选☑️控制台的 Disable cache 选项. (这里以Chrome举例, 其他浏览器类似) ajax的错误处理前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外) 实际上, $.ajax 方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 $.ajax 的error回调便会触发. ajax调试技巧有关调试, 如果接口只是做小部分修改. 那么可以使用charles(Mac) 或者fiddler(Windows), 做代理, 将请求的资源替换为本地文件, 或者使用其断点功能, 直接编辑response. 如果是新增接口的调试, 可以本地搭建node服务. 利用hosts文件配置dns + nginx将http请求转发到本地node服务器. 简易的node调试服务器可参考我的 node-webserver . 如下举一个栗子🌰: hosts+nginx+node-webserver假设我们要调试的是 www.test.com 的GET接口. 以下所有步骤以Mac为例, 其他系统, 请自行搜索🔍文件路径. 1) hosts配置. 123sudo vim /etc/hosts#新增一行 127.0.0.1 www.test.com12 2) nginx 配置 123456789101112131415161718192021222324252627brew install nginx #安装#安装成功后进入目标目录cd /usr/local/etc/nginx/cd servers #默认配置入口为nginx.conf.同时servers目录下*.conf文件已自动加入到配置文件列表中vim test.conf#粘贴如下内容server &#123; listen 80; server_name www.test.com; index index.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; location / &#123; proxy_pass http://localhost:10108/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Read-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;#:wq保存并退出#启动nginxsudo nginx -s reload #如果启动了只需重启即可sudo nginx #如果没有启动,便启动之1234567891011121314151617181920212223242526 3) node-webServer 配置 参考 node-webserver . 启动服务前只需更改index.js, 在第9行后插入如下内容: 1234567&apos;get&apos;: &#123; &apos;/&apos;: &#123; getKey : &apos;Welcome to Simple Node WebServer!&apos; &#125;, &apos;接口api&apos;: &apos;你的response内容&apos;//插入的代码 &#125;,123456 如需在nginx中配置CORS, 请看这里: Nginx通过CORS实现跨域. 编码问题XMLHttpRequest 返回的数据默认的字符编码是utf-8, post方法提交数据默认的字符编码也是utf-8. 若页面编码为gbk等中文编码, 那么就会产生乱码. 后端接口测试技巧通常, 如果后端接口开发OK了, 前端同学需要通过一些手段来确认接口是能正常访问的. 使用命令测试OPTIONS请求12345678910111213141516curl -I -X OPTIONS -H &quot;Origin: http://example.com&quot; http://localhost:10108/# responseHTTP/1.1 200 OKX-Powered-By: ExpressContent-Type: text/json;charset=UTF-8Access-Control-Allow-Credentials: trueAccess-Control-Allow-Headers: x-requested-with,Content-TypeAccess-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONSAccess-Control-Allow-Origin: http://example.comAccess-Control-Max-Age: 3600Server: Node WebServerWebsite: https://github.com/Louiszhai/node-webserverDate: Fri, 21 Oct 2016 09:00:40 GMTConnection: keep-aliveTransfer-Encoding: chunked123456789101112131415 以上, http状态码为200, 表示允许OPTIONS请求. GET, POST 请求与GET类似, 其他请求亦然. 12345curl -I -X GET -H &quot;Origin: http://example.com&quot; http://localhost:10108/#HTTP/1.1 200 OKcurl -I -X POST -H &quot;Origin: http://example.com&quot; http://localhost:10108/test#HTTP/1.1 200 OK1234 postman除此之外, 我们还可以通过chrome的postman扩展进行测试. 请看postman素洁的界面: postman支持所有类型的http请求, 由于其向chrome申请了cookie访问权限及所有http(s)网站的访问权限. 因此可以放心使用它进行各种网站api的测试. 同时, 强烈建议阅读本文的你升级postman的使用技巧, 这里有篇: 基于Postman的API自动化测试 , 拿走不谢. ajax移动端兼容性移动端的支持性，请看表. IOS Safari Opera Mini Android Browser Android Chrome Android UC XMLHttpRequest 7.1 - 4.1 53 11(part) fetch - - 52 53 - 其中，IOS Safari 7.1、Android Browser 4.1 4.3 4.4 的webview均是部分支持，存在的缺陷如下： responseType支持json格式 responseType支持blob格式 支持timeout及ontimeout IOS Safari 7.1 X ✔ ✔ Android 4.1 X X X Android 4.3 X X X Android 4.4 X X ✔ 本篇为ajax而生，通篇介绍 XMLHTTPRequest 相关的知识，力求简明，本欲为梳理知识，为读者答疑解惑，但因本人理解所限，难免有所局限，希望正在阅读的你取其精华去其糟粕，谢谢。 参考 路易斯]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle]]></title>
    <url>%2F2018%2F04%2F12%2FOracle%2F</url>
    <content type="text"><![CDATA[之前整理的Oracle笔记，作为一个后端开发，不懂Oracle是不能忍的（虽然我还只是只ROOKIE，2333333333333333）。 常见关键字create 创建 alter 修改 drop 扔掉 truncate 截断 insert 新建 delete删除 update 修改 query 查询 grant 授权 revoke 撤销授权 commit 提交 rollback 回滚 savepoint 保存还原点 基本语句解锁/加锁账户：alter user username account unlock; alter user username account lock; 修改密码：alter user username identified by password; 创建账户：create user username identified by password; 给用户授权/撤销授权：grant dba to username; revoke dba from username; 删除用户：drop user username; 切换用户：conn username/password; 查看当前用户：show user; 查看表结构desc 表名； 修改创建的表名alter table 原表名 rename to 想更改表名； 建表之后增加字段alter table 表名 add 字段名 字段类型； 建表之后修改字段名alter table 表名 rename column 字段名 to 想要更改表名； 建表之后修改字段数据类型alter table 表名 modify 字段名 想要的数据类型； 建表之后删除字段alter table 表名 drop column 想删除字段； 删除表drop table 表名 purge; 插入数据insert into 表名() values(); 修改数据update student set name = ‘xiaogang’; 删除数据delete from student where name = ‘xiaoxin’; 查询数据select * from student; 基本符号like:%：代表任意位的任意字符 _:代表一位上任意字符 escape逃离符：指定一个字符逃离，保证like之后的字符串中出现的字符看作是普通字符。 Ex:select * from student where name like ‘xiao，_%’ escape ‘,’; 运算符：多行函数：聚组函数：组函数count（）记数sum（）求和avg（）平均 max（）最大min（）最小 单行函数：ceil（）：返回大于等于x的最小整数 floor（）：返回小于等于x的最大整数 round（）：四舍五入round（a1,a2）:保留指定位小数位的四舍五入 Ex:select round(3.1415926,3) from dual; //返回3.142 trunc（）:直接截断trunc（a1,a2）:保留制定位数的小数 sign（）：求符号位 正数1 负数-1 零返回0abs（）：且绝对值power（a,b）：求a的b次方sqrt（）：求正平方根转换函数to_number（c）：将一个字符类型的数字变成数值类型to_char（）：将数值类型转换为字符串 将数字转换为字符串 select * from student where ‘456.12’ = to_char(salary); 常用于在货币单位，格式化字符串 select to_char(123123123123.00,’999,999,999,999,999.00’) from dual; 日期转换 to_char（日期，‘yyyy-MM-dd hh24:mi:ss’） JAVA: yyyy-MM-dd HH:mi:ss Oracle:yyyy-mm-dd hh24:mi:ss:xff ff3 毫秒数保留三位 to_date（c1,c2）c1:字符类型的日期 c2:格式 取出年 select to_char（to_date（‘2018-04-04’，‘yyyy-mm-dd’）,’yyyy’） from dual; 取出月 ‘yyyy’换成‘month’ 取出日 ‘yyyy’ 换成‘dd’ 日期函数： 日期可以加减（整数）运算 单位是：天 相差结果是多少天 两个日子没法相加 yyyy 年 year 年 mm 月 month 带”月”的月份 ddd 年中的天 dd 月中的天 d 周中的天 hh 12小时制 hh24 24小时制 mi 分钟 ss 秒 xff 毫秒 add_months（c1,c2） 在某个日子上增加多少个月c1:日期 c2:整数值 select add_months(sysdate,-1) from dual; months_between(c1,c2) 计算两个日期之间的月份计算方式：c1- c2 last_day():计算给定日期的所在月份的最后一天next_day(c1,c2)c1:日期 c2:周中的某天 字符函数lower():转换成小写upper():转换成大写initcap():首字母大写length():求长度substr(c1,c2,c3) 截取字符串c1:被截取的字符串 c2:从哪个位置开始截取 c3:截取长度 默认截取到最后 instr(c1,c2,c3,c4) 索引字符串c1:被查询的字符串 c2:希望找到的字符 c3:从哪个位置开始找 默认为1 c4:第几次出现 select instr(‘woshizhizhuxia’,’z’,1,2) from dual; concat(c1,c2) 拼接字符串 也可以用 || 拼接字符串Ipad(c1,c2,c3) 左侧补全rpad(c1,c2,c3)右侧补全c1:希望补全的字符串 c2:补全到多少位 c3:以哪个字符来补全 trim(c1) 默认c1两侧去除空格trim(c1 from c2) 把c2的两侧溢出指定的c1ltrim(c1,c2) 左侧去除rtrim(c1,c2)右侧去除c1:被去除的字符串 c2:去除的字符串 默认是空格 replace(c1,c2,c3) 完全替换c1:原字符串 c2:被替换的字符串 c3:替换的字符串 通用函数nvl():空值处理nvl(字段，替换显示的内容)nvl2():空值处理二代nvl2(字段，不是空显示什么，是空显示什么)decode(c1,c2,c3,c4,c5,….Cx,Cx+1)c1：原来拿来判断的值 从第二个参数开始，每两个参数看作是一组，拿每一组的第一个参数和c1进行比较 如果相同则返回该组的第二个参数 第一次判断：c2==c1?c3: 第二次判断：c4==c1?c5: 如果参数个数是奇数个，并且最终判断没有相同的数据，则返回空 如果参数个数是偶数个，并且最终判断没有相同的数据，则返回最后一个参数的值 条件取值语句：，（case email –开始条件取值 when ‘3’ –当条件成立 then salary+200 –则 when ‘7’ then salary-200 else salary+500 –默认值 end） –结束 排序 order by排序字段：desc 代表降序 asc 代表升序 order by 后面可以加多个字段 order by 字段1 desc,字段2 asc 分组 group by(前面不能用where 可以在后面用having)根据某一个或多个列上的值，将该列上相同的值所在的记录划分为一个组，这样一张表就可以被划分为多个组，如 果以字段A分组，那么只能直接查询A。 或者用组函数统计其他字段，不能直接查询其他字段。 约束主键约束：primary key 可在表中唯一确定数据的列，主键列应为非空且唯一。 一张表只能有一个主键 外键约束：foreign key 也可以写references在子表中，若一个列上的值引用了母表中主键上的值，这个列便是外键。 非空：not null唯一：unique检查：check 如何添加约束 在创建表时直接添加约束 12345678alter table 表名 add constraint 约束名 约束；Ex:alter table test add constraint a primary key(id);除not null（有些特殊）alter table test modify 列名 constraint 约束名 not null；Ex:alter table test modify salary constraint a not null; 如何删除约束 1alter table 表名 drop constraint 约束名; 多表查询内连接：inner join on 可简写为 join on展示出两张表中有对应关系的数据，可以理解为取交集； 外连接左外连接：left join on 展示左表中的全部数据和右表中与左表有对应关系的数据； Ex:select * from student s left join class c on s.sid = c.id; 右外连接；right join on 展示右表中的全部数据与左表中与右表有对应关系的数据； Ex:select * from student s right join class c on s.sid = c.id; 全连接：full join on显示两张表中有对应关系的数据，无对应关系的也展示。 交叉连接（笛卡尔积）：cross join显示两张表中的数据一一交叉对应。 什么时候用多表查询？什么时候用子表查询？如果查询数据在多个表内，要使用多表连接。 如果不使用子表的数据，只需要使用子表来当条件，需使用子表查询。 子查询中使用了In some any all 这几个关键字，效率低，可以使用多表关联的方式。 rownumrownum是一个伪列，也就是说不是真是存在的，它是随着结果集生成的。 rownum都是从1开始的。 当我们输入：select * from 表 where rownum &gt;5；不会匹配出任何数据，因为oracle只能确定第一个是哪个， 其他的它并不知道从那开始，认定为false； 想要实现 rownum &gt; n rownum 本身是不行的，但是可以先查出一个记过集合，既子查询。 * 实现rownum &gt; n 时注意问题 rownum 不能与order by 同一查询语句中出现。（但在子查询中可使用order by） 不能使用 表名.rownum 若rownum在where之后，只能写rownum &gt; 0 || rownum &lt; 任意数 || rownum &gt;= 1 Ex: 12345678910select * from ( select rownum rn,e.* from ( select * from student order by salary )e where rownum &lt; 9 //这里已经将取出的结果集再次排序 )where rn &gt; 5; 分页时确定当页从哪开始 开始数：int startcount = （curpage -1 ) * pagesize + 1; 结束数：int endcount = curpage * pagesize; rowid是映射每一行物理地址的唯一标识，通常用于删除完全重复的数据。 12//删除重复的数据delete from table_name where rowid not in (select min(rowid) from table_name); 联合关键字： unionunion: select * from school where name like ‘%大’ union select * from school where name like ‘北%’; 若第一条语句中包含第二句中查询的内容，则只展示第一条语句查询的内容。 union all 若第一条语句中包含第二句中查询的内容，都展示出来。 intersect 求交集只展示两条语句查询的内容重复部分。 minus 从第一个查询结果中减去第二个结果中重复出现的in(效率低，用exists代替) not in表示条件符合查询结果中某一个值就成立。 Ex:select * from school where id in (select sid from stduent); select * from school where id not in (select sid from stduent); some/any用法与In相同，In用于无符号，some/any 用与有符号。 all 表示所有的值都大或都小（min,max代表第二条语句中的最大值最小值）>any == &gt;min &lt;any == &lt;max >all == &gt;max]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类型转换]]></title>
    <url>%2F2018%2F03%2F07%2FJava%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天对Java基本类型的转换有了一些新的认知，记录下来。 Java 基本类型转换Java中数据类型主要分为两大类：基本数据类型和引用数据类型。基本数据类型共8种，分别为：布尔型 boolean 未知 字 符型 char 2字节 数值型 byte 1字节 short 2字节 int 4字节 float 4字节 long 8字节 double 8字节。 引用数据类型可分为：类，接口，数组。 在Java中，整数类型（byte/short/int/long）中，对于未声明数据类型的整形，其默认类型为int型。在浮点类型 （float/double）中，对于未声明数据类型的浮点型，默认为double型。 布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，boolean类型与其他基本类型不能进行类型的转换（既不 能进行自动类型的提升，也不能强制类型转换）， 否则，将编译出错。 基本数据类型之间的转换图： 在定义基本类型变量时，每种基本类型的取值范围是有限的，若定义值超出取值范围，则编译错误。Java整数类型取值范 围计算公式（-2^（n-1) 到 2^(n-1)-1)，浮点类型取值范围为float:符号位1 + 幂值位8 + 数值位23，double:符号位1 +幂值 位11 + 数值位52。 超出取值范围错误原因：jvm在编译过程中，对于默认为int类型的数值时，当赋给一个比int型数值范围小的数值类型变量（在此统一称为数值类型k，k可以是byte/char/short类型），会进行判断，如果此int型数值超过数值类型k，那么会直接编译出错。因为你将一个超过了范围的数值赋给类型为k的变量，k装不下嘛，你又没有进行强制类型转换，当然报错了。但是如果此int型数值尚在数值类型k范围内，jvm会自定进行一次隐式类型转换，将此int型数值转换成类型k。这一点有点特别，需要稍微注意下。例如： 123byte a = 1000;float b = (float)3.12;byte c = 3; char类型转换特别之处：char型其本身是unsigned型，同时具有两个字节，其数值范围是0 ~ 2^16-1，因为，这直接导致byte型不能自动类型提升到char，char和short直接也不会发生自动类型提升（因为负数的问题），同时，byte当然可以直接提升到short型。 强制类型转换中，可能会出现负数的输出，如例： 123int a = 233;byte b = (byte)a;System.out.println(b); 上面的例子中输出值是 -23. 为什么结果是-23？需要从二进制存储考虑。 233的二进制表示为：24位0 + 11101001，byte型只有8位，于是从高位开始舍弃，剩下：11101001，由于二进制最高位1表示负数，0表示正数，符号位不变取反，其相应的负数为-23。 若想求负数的二进制，有两种方法：方法①：则他的计算公式为 -N = ~N + 1, ~ 为取反的意思。方法②：用反码补码来计算。（先确定原码，再确定反码（原码符号位不变，其余位取反。），再确定补码（反码 + 1）。注：二进制在计算机中以补码的方式存放的。）例如： 1234-23 的二进制表达首先确定-23的原码位 10111 加上符号位为 110111再确定反码为 101000再确定补码为 101001 再将位数补全（int类型） 加上26位1 当进行数学运算时，数据类型会自动发生提升到运算符左右之较大者，以此类推.当最会的运算结果赋值给指定数值类型时，可能会需要强制类型转换。例如： 123int a = 9;byte b = 1;byte c = (byte)(a + b); Java 按位取反运算符”~” 如何运算正数的原码，反码，补码是一样的！既： 正数9（二进制为：1001）在内存中存储为01001，必须补上符号位（开头的0为符号位）。补码为01001,反码为01001，其中前面加的0是符号位，负数的符号位用1表示 负数-1（二进制为：0001）在内存中存储为10001，开头的1为符号位，在内存中存放为，11111（负数的补码是：符号位不变，其余各位求反，末位加1）既得到11111。 补码为11111 反码为11110 也就是说在求负数的反码.补码时，负数的补码是：符号位不变，其余各位求反，末位加1，既-1的补码为11111,反码是：符号位为1，其余各位求反，但末位不加1，既-1的反码为11110。反码 + 1既是补码。 1234实例： 求~8,计算步骤如下。8的二进制 1000 则补码为：加上符号位 01000取反为 10111 这是~8的补码 求反码既 -1 为 10110符号位不变再次取反为原码 11001 既-9 参考https://www.cnblogs.com/liujinhong/p/6005714.html http://blog.csdn.net/smilecall/article/details/42454471]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 基本类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql5.6部署]]></title>
    <url>%2F2018%2F01%2F19%2FMysql5-6%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Centos安装Mysql,方便以后安装。 数据库 安装必要的组件 12# yum install –y autoconf automake imake libxml2-devel\ expat-devel cmake gcc gcc-c++ libaio libaio-devel bzr bison libtool ncurses5-devel 下载解压mysql软件 12345# cd /usr/local/src# wget -c http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.14-linux-glibc2.5-x86_64.tar.gz -O mysql-5.6.14-linux-glibc2.5-x86_64.tar.gz# tar zxvf mysql-5.6.14-linux-glibc2.5-x86_64.tar.gz –C ../# cd /usr/local/# ln -s mysql-5.6.14-linux-glibc2.5-x86_64 mysql 创建Mysql用户组和用户，及数据库存放目录： 1234567# mkdir -p /data/mysql_data_3306# mkdir -p /data/mysql_log# mkdir -p /data/log-bin# groupadd mysql# useradd mysql -g mysql -M -s /sbin/nologin# chown -R mysql.mysql /data/mysql_data_3306 /data/mysql_log /data/log-bin# chown -R mysql.mysql /usr/local/mysql-5.6.14-linux-glibc2.5-x86_64 配置文件（依具体环境） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# vi /etc/my.cnf [mysqld]# GENERAL #user = mysqldefault-storage-engine = InnoDBsocket = /data/mysql_data_3306/mysql.sockpid-file = /data/mysql_data_3306/mysql.pidport = 3306# MyISAM #key_buffer_size = 1344Mmyisam_recover = FORCE,BACKUP# SAFETY #max_allowed_packet = 16Mmax_connect_errors = 1000000skip_name_resolve# DATA STORAGE #datadir = /data/mysql_data_3306/long_query_time = 1# BINARY LOGGING #log-bin = /data/log-bin/mysql-bin-3306expire-logs-days = 14sync-binlog = 1server-id = 1max_binlog_size = 500M# REPLICATION #relay-log = /data/log-bin/relay-bin-3306slave-net-timeout = 60# CACHES AND LIMITS #tmp_table_size = 32Mmax_heap_table_size = 32Mmax_connections = 500thread_cache_size = 50open_files_limit = 65535table_definition_cache = 4096table_open_cache = 4096# INNODB #innodb_data_file_path = ibdata1:128M;ibdata2:10M:autoextendinnodb_flush_method = O_DIRECTinnodb_log_files_in_group = 2innodb_lock_wait_timeout = 50innodb_log_file_size = 256Minnodb_flush_log_at_trx_commit = 1innodb_file_per_table = 1innodb_thread_concurrency = 8innodb_buffer_pool_size = 8G# LOGGING #log-error = /data/mysql_log/mysql-error-3306.loglog-queries-not-using-indexes = 1slow-query-log = 1long_query_time = 1slow-query-log-file = /data/mysql_log/mysql-slow-3306.log# FOR SLAVE ##binlog-format = ROW#log-slave-updates = true#gtid-mode = on#enforce-gtid-consistency = true#master-info-repository = TABLE#relay-log-info-repository = TABLE#sync-master-info = 1#slave-parallel-workers = 2#binlog-checksum = CRC32#master-verify-checksum = 1#slave-sql-verify-checksum = 1#binlog-rows-query-log_events = 1#report-port = 3306#report-host = 10.1.1.10 系统服务 12345# cp -af /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld_3306# vi /etc/init.d/mysqld_3306修改两处位置：basedir=/usr/local/mysqldatadir=/data/mysql_data_3306 执行如下命令123# chmod 755 /etc/init.d/mysqld_3306# chkconfig --add mysqld_3306# chkconfig --level 345 mysqld_3306 on 初始化数据库 12# cd /usr/local/mysql# ./scripts/mysql_install_db --user=mysql --defaults-file=/etc/my.cnf 启动数据库进程 1# service mysqld_3306 start 修改root密码 1234# /usr/local/mysql/bin/mysql -p -uroot -S /tmp/mysql.sock #这里直接回车就能进入数据库系统Mysql&gt; delete from mysql.user where user=&apos;&apos;;Mysql&gt; update mysql.user set password=PASSWORD(“1qaz2wsx”) where user=&apos;root&apos;;Mysql&gt;flush privileges; 配置环境变量export mysql所在路径]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2017%2F11%2F07%2FShell%2F</url>
    <content type="text"><![CDATA[小记 Shell是命令语言也是程序设计语言，最近在学习Linux，感觉会写点Shell脚本是一个程序员的标配，下面要系统学习一下Shell。 Shell变量 调用变量：$&#123;变量名&#125; （字符串与数组类似） 获取变量长度：$&#123;#变量名&#125; （字符串与数组类似） 字符串的截取与拼接还是非常有用的[#,##,%,%%等8种字符串截取]，个人是参考菜鸟教程 基本运算符 expr表达式计算工具，格式: `expr $a 运算符 $b` (或者可以使用”$[]”可以进行基本运算,不同之处在于不能有空格。) 格式:if 逻辑运算 then ... else ... fi Shell获取参数 方法内 $1 2 3 4 5…[若参数个数大于10，则需${10}] $* 与 $@ 是有区别的。 $*:若参数为 1 2 3 ，以一个单字符串显示所有向脚本传递的参数。 $@:与$*相同，但是使用时加引号，并在引号中返回每个参数。 感觉shell语法跟其他编程语言还是差不多的，但书写上还是有些差别。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
